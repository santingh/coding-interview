
| #  | Problem name                                               | Required operations & guarantees                                                                                                                                                                                                                                                                                       |
| -- | ---------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1  | **Dynamic Median Exchange**<br>(“Stocks with corrections”) | Maintain real-time trade prices for every stock symbol.<br>Support **addTrade(symbol, price)**, **correctTrade(symbol, oldPrice, newPrice)**, and **getMedian(symbol)** → median of *current* prices for that symbol, all in **O(log n)** per call and *O(1)* memory per price.                                        |
| 2  | **k-Frequent Words Feed**                                  | A chat server streams words as they’re posted.  Provide **ingest(word)** in O(1) amortised, and **topK(k)** that returns the *k* most-frequent words so far, each in **O(k)**.  Memory must stay sub-linear when the vocabulary explodes.                                                                              |
| 3  | **Real-Time Task Lottery**                                 | You own a pool of tasks, each with a positive *weight*.  Calls: **add(task, weight)**, **update(task, newWeight)**, **remove(task)**, and **pickRandom()** that returns a task with probability proportional to its current weight—all in **O(1)** expected time.                                                      |
| 4  | **Two-Tier Cache Hit Ratio Window**                        | Edge nodes report “hit” or “miss” events for *RAM* cache and for an *SSD* cache.  Track **hitRateRAM()** and **hitRateSSD()** over the last *exact* 10 minutes at one-second granularity, both in **O(1)** per update and query, with strict *≤ 1 MB* RAM.                                                             |
| 5  | **Trending-Hashtag Board**                                 | Streaming tweets arrive with a single hashtag.<br>Implement **tweet(hashtag)** and **topTrend()** → current hashtag with highest tweets-per-minute *over the last 5 minutes* (ties broken lexicographically) in **O(1)** each.                                                                                         |
| 6  | **Fair-Matchmaker for Rides**                              | Drivers and riders stream in with locations (x, y).  **addRider(id, x, y)**, **addDriver(id, x, y)**, **driverLeaves(id)**, **riderLeaves(id)**, and **matchClosest()** which pairs the geographically closest unmatched rider-driver in **O(log n)**.  Pairs leave the pool automatically.                            |
| 7  | **Weighted Job-Queue Median Lag**                          | A build farm records job *durations* (seconds).  Maintain **enqueue(duration)**, **dequeue()**, and **medianLag()** = median of durations of *currently waiting* jobs, all in **O(log n)** update, **O(1)** query, with streaming arrivals and arbitrary removals.                                                     |
| 8  | **Elastic Rate-Limiter**                                   | For each API key maintain a 1-minute sliding window of requests.  Operations: **allow(key)** → boolean (grant or reject this request) in **O(1)** worst-case, where the per-key quota can change on-the-fly via **updateQuota(key, newLimit)** also in **O(1)**.  Memory must scale with number of *active* keys only. |
| 9  | **Warehouse Robot Fleet Balancer**                         | Robots report their *battery level* once per second.  Need **update(robot, battery%)**, **drain(robot, delta%)**, **getLowestBattery()**, **getHighestBattery()**—all in strict **O(1)**—and the set of robots changes dynamically.                                                                                    |
| 10 | **Multi-Level Time-Series Compressor**                     | A monitoring agent stores one integer metric every second.  Provide **append(x)** and scale-specific queries **avg(last 10 s)**, **avg(last 10 m)**, **avg(last 6 h)**—all O(1) time and sub-linear memory—while supporting a retention of 24 hours with no recomputation when old data expires.                       |

Pick a couple each day, work out a data-structure sketch, then code, test, and benchmark your design.  Happy grinding!
