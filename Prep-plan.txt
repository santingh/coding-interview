DayÂ 1â€‚BitmaskÂ &Â Stateâ€‘Compression
Trick: encode subsets in bits for 2^n DP/BFS

LCÂ 465Â â€“Â Optimal Account Balancing
LCÂ 1239Â â€“Â Maximum Length of a Concatenated String with Unique Characters
LCÂ 1494Â â€“Â Parallel CoursesÂ II



DayÂ 2â€‚Fenwick/Segment Tree & Orderâ€‘Statistic DS
Trick: range updates/queries in O(logÂ n)

LCÂ 307Â â€“Â Range Sum QueryÂ Mutable
LCÂ 315Â â€“Â Count of Smaller Numbers After Self
LCÂ 327Â â€“Â Count of Range Sum



DayÂ 3â€‚Advanced Graph & DP on DAG
Trick: layered BFS, topoâ€sort, DP over DAG, path reconstruction

LCÂ 126Â â€“Â Word LadderÂ II
LCÂ 269Â â€“Â Alien Dictionary
LCÂ 210Â â€“Â Course ScheduleÂ II



DayÂ 4â€‚Trie & Suffix Structures
Trick: multiâ€pattern search via prefix trees (with compression/pruning)

LCÂ 212Â â€“Â Word SearchÂ II
LCÂ 820Â â€“Â Short Encoding of Words
LCÂ 425Â â€“Â Word Squares



DayÂ 5â€‚GreedyÂ +Â Heaps (kâ€‘th & Sliding Windows)
Trick: use priority queues for topâ€‘k, medians, skyline, window extremes

LCÂ 239Â â€“Â Sliding Window Maximum
LCÂ 218Â â€“Â The Skyline Problem
LCÂ 295Â â€“Â Find Median from Data Stream

Monotonic Dequeue problems
1. Sliding-Window Extrema

  Pattern: Maintain a monotonic deque to get max or min in O(1) per step

  239. Sliding Window Maximum (classic max in fixed K window)

  1343. Number of Sub-arrays of Size K and Average â‰¥ Threshold (variant: count windows by checking their min via deque)

2. Shortest â‰¥ K & Longest â‰¤ K (Prefix-Sum + Deque)

  862. Shortest Subarray with Sum â‰¥ K (weâ€™ve done this)

  962. Maximum Width Ramp (same two-pass deque trick to maximize jâ€“i with A[i] â‰¤ A[j])

  1438. Longest Continuous Subarray With Absolute Diff â‰¤ Limit (use two deques: one increasing, one decreasing, to maintain maxâ€“min â‰¤ limit)

3. â€œAt Most / At Least Kâ€ with Monotonic Two-Deque

Pattern: Two deques (or deques + count) to maintain both window max & min

  480. Sliding Window Median (hard: balance two heaps or two multisets; analogous monotonic-structure practice)

  713. Subarray Product Less Than K (two-pointer but monotonic insights help)

  992. Subarrays with K Different Integers (at-most K & at-most Kâˆ’1 double-window trick)

4. Maximum-Value Equations & Prefix-Sum + Deque

  1499. Max Value of Equation (deque on transformed values yâˆ’x)

  1851. Minimum Interval to Include Each Query (sort by right end + min-heap/deque of left ends)

5. Advanced Prefix-Sum Counting (for contrast)

(Not deque, but good to compare)

  325. Maximum Size Subarray Sum Equals K (hash-map of prefix sums)

  930. Binary Subarrays With Sum = S (two-pointer / prefix count)

  1248. Count Number of Nice Subarrays (odd-even counting via prefix)

Suggested Practice Roadmap
  - Re-implement 862 & 962 from scratch until you can write them in 15 minutes.
  - Mix in the two-deque â€œmaxâ€“min â‰¤ limitâ€ (1438) to see how you juggle two monotonic structures.
  - Contrast with the hash-map counting problems (325, 930) to appreciate why deque only works when you only need one best window, not counts.
  - Finally, tackle 1499 (â€œvalue of equationâ€) to see the same deque idea applied on a transformed sequence.



DayÂ 6â€‚Advanced DP (Interval, Digit, Tree/Matrix)
Trick: interval DP, binaryâ€searchÂ +Â DP, memoized DFS on grids/trees

LCÂ 312Â â€“Â Burst Balloons
LCÂ 887Â â€“Â Super Egg Drop
LCÂ 329Â â€“Â Longest Increasing Path in a Matrix



DayÂ 7â€‚Mixedâ€‘Hard Mock & Debrief
45Â min timed set of 3 problems (one each from daysÂ 1â€“6).
30Â min debrief: for each problem, note:
The key â€œahaâ€ trick
One optimization you missed
How youâ€™ll spot it next time


ğŸ“‹ Daily Debrief Template
Trick identified: e.g. â€œused bitmask to compress state.â€
Missed optimization: e.g. â€œforgot to prune DFS early.â€
Nextâ€‘time cue: e.g. â€œwhen constraints nâ‰¤15, think bitmask.â€
